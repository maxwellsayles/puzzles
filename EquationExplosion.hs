{- Input is an arithmetic string of whole numbers interleaved with + or *.
Without assuming any precendence between + and *, compute all possible values
generated by insertion of parentheses.  E.g.

"1 + 2 * 3 + 4" could be parenthesized as "(1 + 2) * (3 + 4)" or
"((1 + 2) * 3) + 4".

The solution here is to split the input at each index into left and right
sides, and then apply addition or multiplication to each pair of the
Cartesian product.

We present two solutions, both are the same, but the second memoizes the
results.  The runtime of the first solution is likely O(n!).  The runtime
of the second solution should be O(m) where m is the size of the output.
Empirically, the output size appears to be at least O(3^n), but I'm not sure
how to prove that it is not larger than O(3^n).
-}

import Data.Array (Array)
import Data.Array.IArray (IArray, array, listArray, (!))
import Data.List (inits, tails)
import Data.Set (Set)
import qualified Data.Set as Set
import Test.HUnit

type Op = Int -> Int -> Int

-- Apply op to all pairs in the cartesian product of ls and rs
applyOp :: Op -> Set Int -> Set Int -> Set Int
applyOp op ls rs =
  Set.fromList [op l r | l <- Set.toList ls, r <- Set.toList rs]

allVals :: [Int] -> [Op] -> Set Int
allVals [x] [] = Set.singleton x
allVals xs ops =
  foldr Set.union Set.empty $ zipWith3 applyOp ops ls rs
  where
    -- All possible left hand sides
    xsl = init $ tail $ inits xs
    opsl = init $ inits ops
    ls = zipWith allVals xsl opsl

    -- All possible right hand sides
    xsr = init $ tail $ tails xs
    opsr = tail $ tails ops
    rs = zipWith allVals xsr opsr

allValsDp :: [Int] -> [Op] -> Set Int
allValsDp xs ops = opt ! (0, n - 1)
  where
    n = length xs

    ops' :: Array Int Op
    ops' = listArray (0, n - 1) ops

    xs' :: Array Int Int
    xs' = listArray (0, n) xs

    opt :: Array (Int, Int) (Set Int)
    opt = array ((0, 0), (n - 1, n - 1))
            [((i, j), helper i j) | i <- [0..n - 1], j <- [i..n - 1]]

    helper i j
      | i == j = Set.singleton $ xs' ! i
      | otherwise = foldr Set.union Set.empty $
                    map valsAt [i..j - 1]
      where
        valsAt k =
          let op = ops' ! k
              ls = opt ! (i, k)
              rs = opt ! (k + 1, j)
          in applyOp op ls rs
            

testIt :: [Int] -> [Op] -> [Int] -> Test
testIt xs ops res = TestCase $ do
  assert $ allVals xs ops == Set.fromList res
  assert $ allValsDp xs ops == Set.fromList res

testSingle :: Test
testSingle = testIt [1] [] [1]

testAddOnly :: Test
testAddOnly = TestList
  [ testIt [1, 2] [(+)] [3]
  , testIt [1, 2, 3] [(+), (+)] [6]
  , testIt [1, 2, 3, 4] [(+), (+), (+)] [10]
  ]

testAddMul :: Test
testAddMul = testIt [1, 2, 3] [(+), (*)] [9, 7]

testMulOnly :: Test
testMulOnly = TestList
  [ testIt [1, 2] [(*)] [2]
  , testIt [1, 2, 3] [(*), (*)] [6]
  , testIt [1, 2, 3, 4] [(*), (*), (*)] [24]
  ]

testAddMulAdd :: Test
testAddMulAdd = testIt [1, 2, 3, 4] [(+), (*), (+)] [11, 15, 21, 13]

testPrimes :: Test
testPrimes =
  let res = allVals [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]
                    [(+), (*), (+), (*), (+), (*), (+), (*), (+)]
  in Set.size res ~?= 1354

testGrowth :: Test
testGrowth =
  let ops = cycle [(+), (*)]
  in TestList
     [ Set.size (allValsDp [1..1] ops) ~?= 1
     , Set.size (allValsDp [1..2] ops) ~?= 1
     , Set.size (allValsDp [1..3] ops) ~?= 2
     , Set.size (allValsDp [1..4] ops) ~?= 4
     , Set.size (allValsDp [1..5] ops) ~?= 10
     , Set.size (allValsDp [1..6] ops) ~?= 22
     , Set.size (allValsDp [1..7] ops) ~?= 59
     , Set.size (allValsDp [1..8] ops) ~?= 149
     , Set.size (allValsDp [1..9] ops) ~?= 436
     , Set.size (allValsDp [1..10] ops) ~?= 1159
     , Set.size (allValsDp [1..11] ops) ~?= 3465
     , Set.size (allValsDp [1..12] ops) ~?= 9349
     , Set.size (allValsDp [1..13] ops) ~?= 28666
     , Set.size (allValsDp [1..14] ops) ~?= 78808
     , Set.size (allValsDp [1..15] ops) ~?= 240091
     ]

tests :: Test
tests = TestList
  [ testSingle
  , testAddOnly
  , testAddMul
  , testMulOnly
  , testAddMulAdd
  , testPrimes
  , testGrowth
  ]

main :: IO ()
main = runTestTT tests >> return ()
