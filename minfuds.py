"""
This problem was from codility.com in March 2010.

Given two arrays of n integers A and B, let 

F(x, k) = A[k]*x + B[k]
U(x) = max {F(x,k) : 0 \le k < n}
D(x) = min {F(x,k) : 0 \le k < n}
S(x) = U(x) - D(x)

find the minimum S(x) where x can be any real number.

Notice that
F(x, k) = A[k]*x + B[k]
resembles the equation for a line
y = m*x + b.

We can reduce this problem to the problem of
given a set of lines, for all real x,
what is the minimum vertical distance including all lines.

We give two solutions, one in O(nlogn) and
another for sanity testing in O(n^3).
"""


def evalLine(line, x):
    return line[0]*x + line[1]


def intersectLines(P, Q):
    """
    Given two lines defined as Ax+B=y, 
    compute the x coordinate of intersection.
    A_1*x+B_1 = A_2*x+B_2
    x = (B_2 - B_1)/(A_1 - A_2)
    """
    return float(Q[1] - P[1]) / float(P[0] - Q[0])


def minfuds(A, B):
    """
    Given a set of lines, computes the minimum vertical distance
    between the highest line and lowest line for some all x.

    We only need to consider points of intersections between lines.
    Furthermore, we can consider the upper and lower convex curves
    generated by the set of lines.

    The algorithm takes O(nlogn) to sort the set of lines by slope,
    and then O(n) to compute the convex surfaces and O(n) to evaluate
    the minimum and maximum of these surfaces.

    The algorithm is dominanted by sorting in O(nlogn).
    """
    if len(A) == 0 or len(A) == 1:
        return 0

    # sort by ascending slope
    I = sorted(zip(A, B))

    # remove parallel lines
    U = [I[0]]
    L = [I[0]]
    for i in xrange(1, len(I)):
        if I[i][0] != U[-1][0]:
            U.append(I[i])
            L.append(I[i])
        else:
            U[-1] = I[i]

    # all parallel lines?
    if len(U) == 1:
        return U[0][1] - L[0][1]

    # lower lines are in reverse order
    L.reverse()

    # build upper and lower curves
    topCurve = computeConvexity(U)
    bottomCurve = computeConvexity(L)

    # set initial loop values
    i = 0
    j = 0
    topLine = U[0]
    bottomLine = L[0]
    if topCurve[0][0] < bottomCurve[0][0]:
        x = topCurve[0][0]
        topLine = topCurve[0][1]
        i = 1
    else:
        x = bottomCurve[0][0]
        bottomLine = bottomCurve[0][1]
        j = 1

    u = evalLine(topLine, x)
    l = evalLine(bottomLine, x)
    res = u - l

    # iterate over the top and bottom points of the curve
    # computing the minimum value possible
    while i < len(topCurve) and j < len(bottomCurve):
        # find smaller x of the two curve points
        if topCurve[i][0] < bottomCurve[j][0]:
            x = topCurve[i][0]
            topLine = topCurve[i][1]
            i += 1
        else:
            x = bottomCurve[j][0]
            bottomLine = bottomCurve[j][1]
            j += 1

        u = evalLine(topLine, x)
        l = evalLine(bottomLine, x)
        res = min(res, u - l)

    # finish off top curve
    while i < len(topCurve):
        x = topCurve[i][0]
        u = evalLine(topCurve[i][1], x)
        l = evalLine(bottomCurve[-1][1], x)
        res = min(res, u - l)
        i += 1

    # finish off bottom curve
    while j < len(bottomCurve):
        x = bottomCurve[j][0]
        u = evalLine(topCurve[-1][1], x)
        l = evalLine(bottomCurve[j][1], x)
        res = min(res, u - l)
        j += 1

    return res



def computeConvexity(lines):
    """
    Given a set of lines in sorted order by slope,
    computes the list of points and lines of the convex surface.
    
    For each line in the list, we intersect it with the previous 
    line on the curve.  If the x is earlier than the x on the previous
    segment on the curve, we remove the last segment and repeat
    by intersection the line with the new last segment.

    This is O(n) since each line in the list is processed and can
    only be added or removed from the curve at most once.
    """
    curve = []
    i = 1
    while i < len(lines):
        if len(curve) > 0:
            line = curve[-1][1]
        else:
            line = lines[0]
        x = intersectLines(line, lines[i])

        while len(curve) > 0 and x <= curve[-1][0]:
            curve.pop()
            if len(curve) > 0:
                line = curve[-1][1]
            else:
                line = lines[0]
            x = intersectLines(line, lines[i])

        curve.append((x,lines[i]))
        i += 1

    return curve


def sanity(A, B):
    """
    This is the O(n^3) version.

    We compute the intersections for each pair of lines, O(n^2),
    and then compute the minimum and maximum point of all lines, O(n).
    
    We take the minimum of all distances.
    """
    I = sorted(zip(A, B))

    # generate all x points where an intersection occurs
    xs = set([])
    for i in xrange(len(I)):
        for j in xrange(i+1,len(I)):
            if I[i][0] != I[j][0]:
                # only if the lines aren't parallel
                xs.add(intersectLines(I[i], I[j]))
    xs = list(xs)

    # for a given x, find the difference
    # between the highest and lowest line
    def f(x):
        t = map(lambda l: evalLine(l, x), I)
        return max(t) - min(t)

    # return the minimum of these distances
    return min(map(f, xs))

    
if __name__ == '__main__':

    from random import randint
    n = 256
    A = [randint(-10000, 10000) for x in xrange(n)]
    B = [randint(-10000, 10000) for x in xrange(n)]

    print minfuds(A, B)
    print sanity(A, B)
